---
output: html_document
editor_options: 
  chunk_output_type: console
---

```         
   ---
```

title: "Visium HD Analysis" output: html_notebook ---

# Load Libraries

We load the libraries necessary for processing scRNAseq data.

```{r libraries}

# RUN THIS
# .libPaths(c('/n/app/bcbio/R4.3.1_singlecell_dev/', '/n/app/bcbio/R4.3.1_singlecell'))
# .libPaths('../libs/')
library(tidyverse)
library(Seurat)
library(patchwork)
library(qs)
library(Banksy)
library(SeuratWrappers)

# needed if running full workflow but not for lesson
options(future.globals.maxSize= 2000000000)
# library(Azimuth)

```

# Preprocess Data

Sequencing facilities often output scRNAseq data, including spatial scRNAseq data, in FASTQ format. Because this is VisiumHD data from 10X genomics, we use their proprietary preprocessing software [Space Ranger](https://www.10xgenomics.com/support/software/space-ranger/latest) to process the FASTQ files into a count matrix and other images.

<!-- TODO link to spaceranger report -->

# Create Seurat Object

The Seurat object is a custom list-like object that has well-defined spaces to store specific information/data for single cell experiments, including spatial experiments and Visium HD.

The Seurat package provides a function `Load10X_Spatial` to easily create a Seurat object from the output of Space Ranger.

In the Visium HD assay, the barcodes are patterned in a continuous grid of 2x2 µm squares. By default, the Space Ranger pipeline creates 8x8 µm and 16x16 µm bins of gene expression data. Our Seurat object will have data from both of these binnings, but for the purposes of this lesson, we will use the 16µm binning.

```{r create object}

# DO NOT RUN THIS CHUNK, for example purposes only

#################### for one sample ############################################
localdir <- '../final/LIB064899_CRN00296522_MsBrain-FF-A1/spaceranger/outs/'
# to load raw feature matrix
object <- Load10X_Spatial(data.dir = localdir,
                          filename = 'raw_feature_bc_matrix.h5',
                          bin.size = 16)

# cropped.coords <- Crop(object[["slice1.016um"]], x = c(500, 1200), y = c(800, 1600), coords = "plot")
# object[["zoom"]] <- cropped.coords
# 
# object_subset <- subset(object, cells = object@images$zoom$centroids@cells)
# object_subset[["zoom"]] <- NULL
# 
# SpatialDimPlot(object_subset)

# to load spaceranger-filtered feature matrix
object <- Load10X_Spatial(data.dir = localdir)
DefaultAssay(object) <- "Spatial.008um"

##################### for multiple samples #####################################

localdir <- '../final'
samples <- list.files(localdir)[grepl('LIB', list.files(localdir))]
names(samples) <- unlist(transpose(strsplit(samples, '_'))[3])
for (i in 1:length(samples)){
  object_sample <- Load10X_Spatial(data.dir = paste0(localdir, '/', samples[i], '/', 'spaceranger/outs/'),
                                   slice = names(samples)[i],
                                   filename = 'raw_feature_bc_matrix.h5',
                                   bin.size = 16)  # need to read in one bin at a time for multiple samples
  object_sample$orig.ident <- names(samples)[i]
  assign(paste0(samples[i], "_seurat"),
         object_sample) # stores Seurat object in variable of corresponding sample name
}
seurat_ID <- paste0(samples, "_seurat") # get names of all objects

object <- merge(x = get(seurat_ID[1]),
                      y = get(seurat_ID[2]),
                      add.cell.ids = samples,
                      project = "mouse_brain_visiumhd")

# for more than 2 samples
rest_of_samples <- get(seurat_ID[2])
for (i in 3:length(seurat_ID)) {
  rest_of_samples <- c(rest_of_samples, get(seurat_ID[i]))
} ## makes a list of all seurat objects

seurat_merge <- merge(x = get(seurat_ID[1]),
                      y = rest_of_samples,
                      add.cell.ids = samples,
                      project = "mouse_brain_visiumhd")


```

```{r load seurat object}

# RUN THIS
object <- qread('../data_processed/MsBrain_FF-A1_subset.qs')

```

# Quality Control

The main objective of quality control is to filter the data so that we include only true cells that are of high quality. This makes it so that when we cluster our cells, it is easier to identify distinct cell type populations.

Challenges include:

-   Delineating cells that are poor quality from less complex cells
-   Choosing appropriate thresholds for filtering, so as to keep high quality cells without removing biologically relevant cell types

Various metrics can be used to filter low quality cells from high quality ones, including:

-   UMI counts per bin
-   Genes detected per bin
-   Complexity (novelty score)
-   Mitochondrial counts ratio

For this lesson, we will examine the distributions of UMI counts per bin and genes detected per bin to determine reasonable thresholds for those metrics for QC filtering.

## Pre-Filtering

```{r visualize pre qc data}

object_meta <- object@meta.data

dist_counts_before <- object_meta %>%
  ggplot(aes(x=nCount_Spatial.016um)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density") +
  ggtitle('PostQC Genes/Bin')

dist_features_before <- object_meta %>%
  ggplot(aes(x=nFeature_Spatial.016um)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density") +
  ggtitle('PostQC UMIs/Bin')

dists_before <- dist_counts_before | dist_features_before
dists_before

```

## Perform Filtering

```{r perform filtering}
object_filt <- subset(object, (nCount_Spatial.016um > 100) & 
                        (nFeature_Spatial.016um > 100))
```

## Post-Filtering

```{r visualize post qc data}

object_filt_meta <- object_filt@meta.data

dist_counts_after <- object_filt_meta %>%
  ggplot(aes(x=nCount_Spatial.016um)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density") +
  ggtitle('PostQC Genes/Bin')

dist_features_after <- object_filt_meta %>%
  ggplot(aes(x=nFeature_Spatial.016um)) +
  geom_density(alpha = 0.2) +
  scale_x_log10() +
  theme_classic() +
  ylab("Cell density") +
  ggtitle('PostQC UMIs/Bin')

dists_after <- dist_counts_after | dist_features_after
dists_after

```

# Visualize Data

We can visualize the number of counts per bin, both as a distribution and layered on top of the tissue image. Note that many spots have very few counts, in part due to low cellular density or cell types with low complexity in certain tissue regions.

```{r visualize distributions}

vln_counts_after <- VlnPlot(object_filt, 
                            features = "nCount_Spatial.016um", 
                            pt.size = 0, 
                            group.by = 'orig.ident') + 
  NoLegend() + scale_y_log10()

vln_features_after <- VlnPlot(object_filt, 
                            features = "nFeature_Spatial.016um", 
                            pt.size = 0, 
                            group.by = 'orig.ident') + 
  NoLegend() + scale_y_log10()


 
vln_counts_after | vln_features_after
```

```{r visualize on image}
# RUN THIS
image_counts <- SpatialFeaturePlot(object_filt, 
                                   feature = 'nCount_Spatial.016um', 
                                   pt.size.factor = 8)
image_features <- SpatialFeaturePlot(object_filt, 
                                     features = "nFeature_Spatial.016um", 
                                     pt.size.factor = 8) 

image_counts | image_features

```

# Normalize Data

Normalization is important in order to make expression counts comparable across genes and/or sample. We note that the best normalization methods for spatial data are still being developed and evaluated. Here we use a standard log-normalization.

```{r normalize}

object_filt <- NormalizeData(object_filt, assay = 'Spatial.016um')

```

# Unsupervised Clustering

The authors of the Seurat package recommend the Seurat v5 sketch clustering workflow exhibits improved performance, especially for identifying rare and spatially restricted groups. Sketch-based analyses aim to ‘subsample’ large datasets in a way that preserves rare populations. Here, we sketch the Visium HD dataset, perform clustering on the subsampled cells, and then project the cluster labels back to the full dataset.

```{r create sketch assay}

object_filt <- FindVariableFeatures(object_filt)
object_filt <- ScaleData(object_filt)
# we select 10,000 cells and create a new 'sketch' assay
object_filt <- SketchData(
  object = object_filt,
  assay = 'Spatial.016um',
  ncells = 10000,
  method = "LeverageScore",
  sketched.assay = "sketch"
)

```

```{r perform sketched clustering}

# switch analysis to sketched cells
DefaultAssay(object_filt) <- "sketch"

# perform clustering workflow
object_filt <- FindVariableFeatures(object_filt)
object_filt <- ScaleData(object_filt)
object_filt <- RunPCA(object_filt, assay = "sketch", reduction.name = "pca.sketch")
object_filt <- FindNeighbors(object_filt, assay = "sketch", reduction = "pca.sketch", dims = 1:50)
object_filt <- FindClusters(object_filt, cluster.name = "seurat_cluster.sketched", resolution = .65)
object_filt <- RunUMAP(object_filt, reduction = "pca.sketch", reduction.name = "umap.sketch", return.model = T, dims = 1:50)

```

```{r project clusters}

object_filt <- ProjectData(
  object = object_filt,
  assay = "Spatial.016um",
  full.reduction = "full.pca.sketch",
  sketched.assay = "sketch",
  sketched.reduction = "pca.sketch",
  umap.model = "umap.sketch",
  dims = 1:50,
  refdata = list(seurat_cluster.projected = "seurat_cluster.sketched")
)

```

```{r visualize clusters}

object_filt$seurat_cluster.projected <- object_filt$seurat_cluster.projected %>% 
  as.numeric %>% as.factor()

DefaultAssay(object_filt) <- "sketch"
Idents(object_filt) <- "seurat_cluster.sketched"
p1 <- DimPlot(object_filt, reduction = "umap.sketch", label = F, cols = 'polychrome') + 
  ggtitle("Sketched clustering") + 
  theme(legend.position = "bottom")

# switch to full dataset
DefaultAssay(object_filt) <- "Spatial.016um"
Idents(object_filt) <- "seurat_cluster.projected"
p2 <- DimPlot(object_filt, reduction = "full.umap.sketch", label = F, raster = F, 
              cols = 'polychrome') +
  ggtitle("Projected clustering") + 
  theme(legend.position = "bottom")

p1 | p2
```

```{r visualize clusters on image}

color_pal = Seurat::DiscretePalette(n = length(unique(object_filt$seurat_cluster.projected)),
                                    palette = "polychrome")
names(color_pal) <- sort(unique(object_filt$seurat_cluster.projected))
image_seurat_clusters <- SpatialDimPlot(object_filt, 
                                        group.by = 'seurat_cluster.projected', 
                                        pt.size.factor = 8, cols = color_pal) +
  guides(fill=guide_legend(ncol=2))


image_seurat_clusters
```

# Cell Type Identification

Now that we have identified our desired clusters, we can move on to cell type identification, which will allow us to verify the identity of the cells contained in our various clusters.

Azimuth is a web application that uses an annotated reference dataset to automate the processing, analysis, and interpretation of a new single-cell RNA-seq experiment.

```{r run azimuth}

object_filt <- RunAzimuth(object_filt, reference = "mousecortexref")

```

```{r plot annotations}

color_pal = Seurat::DiscretePalette(n = length(unique(object_filt$predicted.subclass)),
                                    palette = "polychrome")
names(color_pal) <- sort(unique(object_filt$predicted.subclass))
SpatialDimPlot(object_filt, pt.size.factor = 8, group.by = 'predicted.subclass',
               cols = color_pal) 

 DimPlot(object_filt, group.by = 'predicted.subclass', 
         reduction = "full.umap.sketch", label = F, raster = F, 
              cols = 'polychrome')
```


```{r run banksy}
object_filt <- RunBanksy(object_filt, lambda = 0.8, verbose = T,
                         assay = 'Spatial.016um', slot = 'data', k_geom = 50)
object_filt <- RunPCA(object_filt, assay = "BANKSY", 
                      reduction.name = "pca.banksy", 
                      features = rownames(object_filt), npcs = 30)
object_filt <- FindNeighbors(object_filt, reduction = "pca.banksy", 
                             dims = 1:30)
object_filt <- FindClusters(object_filt, cluster.name = "banksy_cluster",
                            resolution = 0.5)
```
```{r}

color_pal = Seurat::DiscretePalette(n = length(unique(object_filt$banksy_cluster)),
                                    palette = "polychrome")
names(color_pal) <- sort(unique(object_filt$banksy_cluster))

image_banksy_clusters <- SpatialDimPlot(object_filt, group.by = "banksy_cluster", pt.size.factor = 7,
               cols = color_pal)

image_seurat_clusters | image_banksy_clusters

```


```{r}
cortex <- subset(object_filt, seurat_cluster.projected %in% c(12, 18, 19, 7, 2, 4))

SpatialDimPlot(cortex, group.by = 'seurat_cluster.projected', 
               pt.size.factor = 8, cols = color_pal)
```

```{r sketch cortex}
DefaultAssay(cortex) <- 'Spatial.016um'
cortex <- FindVariableFeatures(cortex)
cortex <- SketchData(
  object = cortex,
  ncells = 3000,
  method = "LeverageScore",
  sketched.assay = "sketch"
)

DefaultAssay(cortex) <- "sketch"
cortex <- ScaleData(cortex)
cortex <- RunPCA(cortex, assay = "sketch", reduction.name = "pca.cortex.sketch", verbose = T)
cortex <- FindNeighbors(cortex, reduction = "pca.cortex.sketch", dims = 1:50)
cortex <- RunUMAP(cortex, reduction = "pca.cortex.sketch", reduction.name = "umap.cortex.sketch", return.model = T, dims = 1:50, verbose = T)
```

```{r}
ref <- readRDS("../data_processed/allen_scRNAseq_ref.Rds")


```
