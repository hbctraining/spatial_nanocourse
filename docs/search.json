[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nSpatial Transcriptomics Nanocourse\n\n\n\nAudience\nComputational skills required\nDuration\n\n\n\n\nBiologists\nIntroduction to R\n1 session in-person (~1h 45 min of trainer-led time)\n\n\n\n\nDescription\nThis repository contains materials for a module which is part of a Nanocourse organized by the Single Cell Core at HMS. The nanocourse titled “Spatial Transcriptomics: Key Technologies, Experimental Considerations, and Data Analysis” introduces the fundamentals of data analysis for spatial transcriptomics, including common techniques and tools. In this module we walk through the analysis workflow for a Visium HD experiment.\n\n\nLearning Objectives\n\nDescribe the steps in a Visium HD analysis workflow\nUse Seurat and associated tools to perform analysis of spatial transcriptomics data, including QC metric evaluation, normalization, clustering, and marker identification\n\n\n\nDataset\nThe dataset is located in “Dataset for workshop” -&gt; “Day 1- NGS-based- VisiumHD” in the course DropBox.\n\n\nLessons\n\nVisium HD Analysis with Seurat\n\n\nInstallation Requirements\n\nApplications\nDownload the most recent versions of R and RStudio for your laptop:\n\nR (version 4.4.0 or above)\nRStudio\n\n\n\nPackages for R\n\n\n\n\n\n\nNotes for installing packages\n\n\n\nNote 1: Install the packages in the order listed below.\nNote 2: All the package names listed below are case sensitive!\nNote 3: If you have a Mac, download and install this gfortan tool before installing your packages if using R versions 4.3.0 up to 4.4.3 or this gfortran tool if using R versions after 4.4.3.\nNote 4: At any point (especially if you’ve used R/Bioconductor in the past), in the console R may ask you if you want to update any old packages by asking Update all/some/none? [a/s/n]:. If you see this, type “a” at the prompt and hit Enter to update any old packages. Updating packages can sometimes take quite a bit of time to run, so please account for that before you start with these installations.\nNote 5: If you see a message in your console along the lines of “binary version available but the source version is later”, followed by a question, “Do you want to install from sources the package which needs compilation? y/n”, type n for no, and hit enter.\n\n\n(1) Install the following packages with CRAN using the install.packages() function:\n\ninstall.packages(\"ggplot2\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"Seurat\")\ninstall.packages(\"patchwork\")\ninstall.packages(\"qs2\")\ninstall.packages(\"quadprog\")\ninstall.packages(\"remotes\")\ninstall.packages(\"devtools\")\ninstall.packages(\"BiocManager\")\n\n(2) Install the packages listed below from Bioconductor using the BiocManager::install() function.\n\nlibrary(BiocManager)\n\nBiocManager::install(\"scuttle\")\nBiocManager::install(\"scater\")\nBiocManager::install(\"bluster\")\nBiocManager::install(\"Voyager\")\nBiocManager::install(\"glmGamPoi\")\nBiocManager::install(\"SpatialFeatureExperiment\")\nBiocManager::install(\"scattermore\")\nBiocManager::install(\"sfarrow\")\n\n(3) Install the packages listed below from GitHub using the given remotes:install_github or devtools::install_github command.\n\nlibrary(remotes)\nlibrary(devtools)\noptions(timeout = 600000000)\n\nremotes::install_github(\"satijalab/seurat-wrappers\")\nremotes::install_github(\"prabhakarlab/Banksy@devel\")\ndevtools::install_github(\"dmcable/spacexr\", build_vignettes = FALSE)\n\n(4) Finally, please check that all the packages were installed successfully by loading them one at a time using the library() function.\n\nlibrary(SpatialFeatureExperiment)\nlibrary(scuttle)\nlibrary(scater)\nlibrary(bluster)\nlibrary(Voyager)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(qs2)\nlibrary(quadprog)\nlibrary(remotes)\nlibrary(devtools)\nlibrary(BiocManager)\nlibrary(glmGamPoi)\nlibrary(SeuratWrappers)\nlibrary(Banksy)\nlibrary(spacexr)\nlibrary(sfarrow)\nlibrary(scattermore)\n\n(5) Once all packages have been loaded, run sessionInfo().\n\nsessionInfo()"
  },
  {
    "objectID": "lessons/visium_hd.html",
    "href": "lessons/visium_hd.html",
    "title": "Visium HD Analysis",
    "section": "",
    "text": "Approximate time: 2 hours and 45 minutes"
  },
  {
    "objectID": "lessons/visium_hd.html#mouse-brain-visium-hd-dataset",
    "href": "lessons/visium_hd.html#mouse-brain-visium-hd-dataset",
    "title": "Visium HD Analysis",
    "section": "Mouse Brain Visium HD Dataset",
    "text": "Mouse Brain Visium HD Dataset\nThe Visium HD platform is compatible with human and mouse fresh frozen, fixed frozen, and formalin-fixed paraffin-embedded (FFPE) tissue sections. For this lesson, we will be working with data from a fresh frozen coronal section of a mouse brain sample. The end goal of this exercise to annotate the cortical layers.\nVisium HD matches the 6.5 × 6.5 mm imaging area of the earlier Visium platform but now achieves higher resolution by dividing that area into 11 million tiles. These 2µm x 2µm squares are arrayed in a continuous lawn across the entire capture area. The squares are each uniquely barcoded with an oligonucleotide and contain probes allowing for the detection of the full coding transcriptome. As such, Visium HD is categorized as a sequencing-based technology.\n\n\n\n\n10x Visium HD Spatial Gene Expression Manual\n\n\n\nThe single-digit micron resolution is a big technological improvement over Visium’s original ∼55μm spots. Because a single spot can include several cell types, the dataset is not straightforward to annotate. As a result, many methods model each spot as a mixture, assigning proportion values for each cell type within that spot. Each spot is represented as a piechart showing proportions of the cell type composition.\n\n\n\nMa, Y., et al. Nat Biotechnol (2022), Figure 1\n\n\nWhile Visium HD reduces bin size to approach single-cell resolution, it is important to note that sequencing-based spatial transcriptomics captures RNA from a defined spatial area rather than from isolated cells. As a result, transcripts from multiple cells overlapping a bin can be pooled and sequenced together. This means that even small bins may contain mixed cellular signals, which has important implications for downstream analyses such as differential gene expression.\n\n\n\n\n\n\nImaging-based technologies\n\n\n\n\n\nThese methods use fluoresence to quantify gene expression directly on a tissue section. They rely on fluoresence in situ hybridization (FISH) to measure the expression of a select panel of genes (chosen by the researcher) using probes. Since transcripts are detected within intact cells, expression values can be assigned to individual cells following cell segmentation.\nSome popular imaging-based technologies include:\n\nseqFISH\nMERFISH\nXenium"
  },
  {
    "objectID": "lessons/visium_hd.html#preprocessing-data-with-spaceranger",
    "href": "lessons/visium_hd.html#preprocessing-data-with-spaceranger",
    "title": "Visium HD Analysis",
    "section": "Preprocessing Data with SpaceRanger",
    "text": "Preprocessing Data with SpaceRanger\nSequencing facilities often output scRNA-seq data, including spatial scRNA-seq data, in FASTQ format. Because this is Visium HD data from 10X Genomics, we used their proprietary pre-processing software Space Ranger to process the FASTQ files into a count matrix and other images. The spaceranger count command aligns the reads in the FASTQ files against a reference genome and provides their spatial location using the oligonucleotide barcode.\nNote that Space Ranger requires a Linux system with at least 32 cores, 64GB of RAM, and 1TB of disk space.\n\n\n\n\n\n\nExample spaceranger count command\n\n\n\n\n\nA sample command for running spaceranger count is:\n\nspaceranger count --id=hd_count \\\n   --transcriptome=/path/to/refdata-gex-GRCh38-2020-A \\\n   --fastqs=/path/to/fastq \\\n   --probe-set=/path/to/Visium_Human_Transcriptome_Probe_Set_v2.0_GRCh38-2020-A.csv \\\n   --slide=H1-YD7CDZK \\\n   --area=A1 \\\n   --cytaimage=/path/to/CAVG10539_2023-11-16_14-56-24_APPS115_H1-YD7CDZK_A1_S11088.tif \\\n   --image=/path/to/APPS115_11088_rescan_01.btf \\\n   --create-bam=false\n\n\n\n\nWhen spaceranger count completes successfully, it will generate a variety of outputs (seen below), which will enable the analyst to perform further analysis in R/Python or using the proprietary Loupe browser from 10X Genomics. A good starting point is to take a look at the QC of the sample in the web summary, which we have provided in reports/ folder that you downloaded.\n\n\n\n10x Space Ranger Documentation\n\n\nIn the Visium HD assay, Space Ranger aggregates transcript counts into square spatial bins of different sizes, typically:\n\n2µm x 2µm\n8µm x 8µm\n16µm x 16µm\n\nHaving access to 2μm bins, along with matched high-resolution tissue morphology, provides a great opportunity to reconstruct single cells from the data. However, because the 2µm x 2µm bins (and even the 8µm x 8µm bins) are very small, there is a potential for very little biological signal to be captured per bin. Additionally, the sheer number of bins at these higher resolutions can substantially increase computational demands in terms of memory usage and processing time.\nFor this lesson, we will use the 16µm x 16µm bins of the cropped Visium HD slide to run locally on laptops."
  },
  {
    "objectID": "lessons/visium_hd.html#ngs-based-spatial-transcriptomics-analysis-workflow",
    "href": "lessons/visium_hd.html#ngs-based-spatial-transcriptomics-analysis-workflow",
    "title": "Visium HD Analysis",
    "section": "NGS-based Spatial Transcriptomics Analysis Workflow",
    "text": "NGS-based Spatial Transcriptomics Analysis Workflow\nThe overarching steps for analyzing a sequencing-based transcriptomics dataset is as follows:"
  },
  {
    "objectID": "lessons/visium_hd.html#downloading-the-data",
    "href": "lessons/visium_hd.html#downloading-the-data",
    "title": "Visium HD Analysis",
    "section": "Downloading the Data",
    "text": "Downloading the Data\nFor this module, we will be working within an RStudio project. In order to follow along you should have downloaded the R project.\n\n\n\n\n\n\nWhere to download the data\n\n\n\nIf you haven’t done this already, the project is located in “Dataset for workshop” -&gt; “Day 2- NGS-based- VisiumHD” in the course DropBox.\n\n\nOnce downloaded, you should see a file called visiumHD_nanocourse.zip on your computer (likely, in your Downloads folder).\n\nUnzip this file. This will result in a folder of the same name.\nMove the folder to the location on your computer where you would like to perform the analysis.\nOpen up the folder. The contents will look like the screenshot below:\n\n\n\nLocate the .Rproj file and double-click on it. This will open up RStudio with the “visiumHD_nanocourse” project loaded.\nOpen a new Rscript file.\nStart with some comments to indicate what this file is going to contain:\n\n\n# February 2026\n# Spatial Transcriptomics\n# Visium HD Demo\n# Harvard Chan Bioinformatics Core\n\n\nSave the Rscript in the code folder as visiumHD.R. Your working directory should look something like this:"
  },
  {
    "objectID": "lessons/visium_hd.html#loading-libraries",
    "href": "lessons/visium_hd.html#loading-libraries",
    "title": "Visium HD Analysis",
    "section": "Loading Libraries",
    "text": "Loading Libraries\nNext, we will need to be sure to load the libraries that we will be using:\n\n# Load libraries\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(Seurat)\nlibrary(qs)\nlibrary(SeuratWrappers)\nlibrary(Banksy)\nlibrary(quadprog)\nlibrary(spacexr)\n\n# Increases the size of the default vector\noptions(future.globals.maxSize= 2000000000)"
  },
  {
    "objectID": "lessons/visium_hd.html#pre-filtering",
    "href": "lessons/visium_hd.html#pre-filtering",
    "title": "Visium HD Analysis",
    "section": "Pre-filtering",
    "text": "Pre-filtering\nIn order to create some plots, we will first need to create a metadata dataframe using this command:\n\nobject_meta &lt;- object@meta.data\n\nNow we can plot the number of UMIs (nCount) and the number of genes (nFeature) side-by-side. We expect to see a bimodal distribution for both of the plots, with one peak representing bins of lower-quality cells with fewer genes/UMIs and another peak representing bins that contain healthy cells with more genes and UMIs. Ideally, the peak representing lower-quality and dying cells is small and the peak representing healthy cells is large.\n\n# Create a plot for nUMI\ndist_counts_before &lt;- object_meta %&gt;%\n  ggplot(aes(x=nCount_Spatial.016um)) +\n  geom_density(alpha = 0.2) +\n  scale_x_log10() +\n  theme_classic() +\n  ylab(\"Cell density\") +\n  xlab(\"Number of UMIs per bin\") +\n  ggtitle('Pre-QC UMIs/Bin') +\n  theme(plot.title = element_text(hjust = 0.5))\n\n# Create a plot for nGene\ndist_features_before &lt;- object_meta %&gt;%\n  ggplot(aes(x=nFeature_Spatial.016um)) +\n  geom_density(alpha = 0.2) +\n  scale_x_log10() +\n  theme_classic() +\n  ylab(\"Cell density\") +\n  xlab(\"Number of genes per bin\") +\n  ggtitle('Pre-QC Genes/Bin') +\n  theme(plot.title = element_text(hjust = 0.5))\n\ndists_before &lt;- dist_counts_before | dist_features_before\ndists_before\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUsing the distribution plots in the app below, what do you think would be good minimum thresholds for nGene and nUMI?"
  },
  {
    "objectID": "lessons/visium_hd.html#post-filtering",
    "href": "lessons/visium_hd.html#post-filtering",
    "title": "Visium HD Analysis",
    "section": "Post-Filtering",
    "text": "Post-Filtering\nWe will apply very minimal filtering here, with nUMI &gt; 100 and nGene &gt; 100. It has been shown that low expression can be biologically meaningful in a spatial context so we won’t be as stringent as we normally are with a scRNA-seq analysis.\n\n# Create a filtered object\nobject_filt &lt;- subset(object, \n                      subset = (nCount_Spatial.016um &gt; 100) & \n                               (nFeature_Spatial.016um &gt; 100))\n\nNow, we can create similar plots with filtered data. As expected, we see that the small left peak in the distribution has vanished, which leaves the higher quality bins that are the majority of the data.\n\n# Create a new metadata data frame from filtered data\nobject_filt_meta &lt;- object_filt@meta.data\n\n# Plot nUMI\ndist_counts_after &lt;- object_filt_meta %&gt;%\n  ggplot(aes(x=nCount_Spatial.016um)) +\n  geom_density(alpha = 0.2) +\n  scale_x_log10() +\n  theme_classic() +\n  ylab(\"Cell density\") +\n  xlab(\"Number of UMIs per bin\") +\n  ggtitle('PostQC UMIs/Bin') +\n  theme(plot.title = element_text(hjust = 0.5))\n\n# Plot nGene\ndist_features_after &lt;- object_filt_meta %&gt;%\n  ggplot(aes(x=nFeature_Spatial.016um)) +\n  geom_density(alpha = 0.2) +\n  scale_x_log10() +\n  theme_classic() +\n  ylab(\"Cell density\") +\n  xlab(\"Number of genes per bin\") +\n  ggtitle('PostQC Genes/Bin') +\n  theme(plot.title = element_text(hjust = 0.5))\n\n# Combine plots side-by-side\ndists_after &lt;- dist_counts_after | dist_features_after\ndists_after\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nHow many cells did we filter out with these thresholds?"
  },
  {
    "objectID": "lessons/visium_hd.html#visualizing-counts-data",
    "href": "lessons/visium_hd.html#visualizing-counts-data",
    "title": "Visium HD Analysis",
    "section": "Visualizing Counts Data",
    "text": "Visualizing Counts Data\nWe can visualize the number of UMIs and gene counts per bin, both as a distribution and layered on top of the tissue image. Let’s start with a violin plot to look at the distribution of UMI counts and gene counts. The input is our post-filtered dataset.\n\n# Violin plot of UMI counts\nvln_counts_after &lt;- VlnPlot(object_filt, \n                            features = \"nCount_Spatial.016um\", \n                            pt.size = 0, \n                            group.by = 'orig.ident') + \n  NoLegend() + scale_y_log10() + ggtitle('nUMI') + xlab('') + ylim(c(100, 15000))\n\n# Violin plot of gene counts\nvln_features_after &lt;- VlnPlot(object_filt, \n                            features = \"nFeature_Spatial.016um\", \n                            pt.size = 0, \n                            group.by = 'orig.ident') + \n  NoLegend() + scale_y_log10() + ggtitle('nGene') +  xlab('') + ylim(c(100, 15000))\n\n\n# Plot both side by side\nvln_counts_after | vln_features_after\n\n\n\n\n\n\n\n\nWe see that both distributions have a similar peak but the nUMI distribution has a much longer tail. This is expected, because while the small physical size of the bins means that most genes will be detected only once or twice, a minority of bins under very transcriptionally active cells may exhibit multiple transcripts of the same gene.\nNext, we can look at the same metrics and the distribution on the actual image itself. Note that there are many spots with few counts, in part due to low cellular density or cell types with low complexity within certain tissue regions.\n\n# Visualizing UMI count across the image\nimage_counts &lt;- SpatialFeaturePlot(object_filt, \n                                   feature = 'nCount_Spatial.016um', \n                                   pt.size.factor = 8)\n\n# Visualizing gene count across the image\nimage_features &lt;- SpatialFeaturePlot(object_filt, \n                                     features = \"nFeature_Spatial.016um\", \n                                     pt.size.factor = 8) \n\n# Plot the two side-by-side\nimage_counts | image_features"
  },
  {
    "objectID": "lessons/visium_hd.html#highly-variable-genes-hvgs",
    "href": "lessons/visium_hd.html#highly-variable-genes-hvgs",
    "title": "Visium HD Analysis",
    "section": "Highly Variable Genes (HVGs)",
    "text": "Highly Variable Genes (HVGs)\nWe will start by defining a set of highly variable genes. Note that this is being done on all bins within our Seurat object. Using this list of genes will help us to quantify the variability and similarity between bins. Essentially, we are looking at genes with high levels of variance while also accounting for the average expression. In doing so, we get a list of genes ranked by how much they change across different cell populations.\n\nobject_filt &lt;- FindVariableFeatures(object_filt)\nobject_filt\n\nAn object of class Seurat \n32285 features across 41818 samples within 1 assay \nActive assay: Spatial.016um (32285 features, 2000 variable features)\n 2 layers present: counts, data\n 1 spatial field of view present: slice1.016um\n\n\nWhen we examine our Seurat object, we can see that FindVariableFeatures() has added 2,000 variable features.\n\n\n\nAnd we can see what the top variables features are for the entire dataset. We would anticipate that these genes correspond to the celltypes in our dataset.\n\nVariableFeatures(object_filt)[1:15]\n\n [1] \"Ttr\"    \"Enpp2\"  \"Sst\"    \"Igf2\"   \"Ecrg4\"  \"Ptgds\"  \"Npy\"    \"Prlr\"  \n [9] \"Clic6\"  \"Hbb-bs\" \"Kl\"     \"Igfbp2\" \"Tac2\"   \"Hba-a2\" \"Cnr1\"  \n\n\nIf we look into the gene Ttr, we can learn that it is “highly expressed in choroid plexus epithelial cells”. If continue looking at the top variable genes, we would hope to see more genes with experimental or celltype specific relevance."
  },
  {
    "objectID": "lessons/visium_hd.html#sketch-downsampling",
    "href": "lessons/visium_hd.html#sketch-downsampling",
    "title": "Visium HD Analysis",
    "section": "Sketch Downsampling",
    "text": "Sketch Downsampling\nNext, we select 10,000 cells and create a new sub-sampled “sketch” assay using the SketchData() function. The function takes a normalized single-cell dataset containing a set of variable features and returns a Seurat object with a new assay (sketch), which consists of 10,000 bins selected based on a “leverage score” for each bin.\nThe leverage score reflects the magnitude of the bin’s contribution to the gene-covariance matrix, and its importance to the overall dataset, with rare populations earning a higher leverage score. As a result, the 10,000 bins we selected for with the sketch oversamples rare populations, retaining the biological complexity of the sample, while drastically compressing the dataset.\n\n# we select 10,000 cells and create a new 'sketch' assay\nobject_filt &lt;- SketchData(\n  object = object_filt,\n  assay = 'Spatial.016um',\n  ncells = 10000,\n  method = \"LeverageScore\",\n  sketched.assay = \"sketch\"\n)\n\nobject_filt\n\nAn object of class Seurat \n64570 features across 41818 samples within 2 assays \nActive assay: sketch (32285 features, 2000 variable features)\n 2 layers present: counts, data\n 1 other assay present: Spatial.016um\n 1 spatial field of view present: slice1.016um\n\n\nWe can see that there are four major changes that have taken place in our Seurat object:\n\nThe number of features in the second line has doubled, because we have added a new assay\nAccordingly, the number of assays has increased from one to two\nThe active assay has changed from Spatial.016um to sketch\nThere is a new line listing additional assays that exist in the Seurat object\n\n\n\n\nWe can also see that the leverage score has been added as a column to the metadata of our object.\n\nView(object_filt@meta.data)"
  },
  {
    "objectID": "lessons/visium_hd.html#clustering-workflow",
    "href": "lessons/visium_hd.html#clustering-workflow",
    "title": "Visium HD Analysis",
    "section": "Clustering Workflow",
    "text": "Clustering Workflow\nNext, we will perform a standard clustering workflow on our sketch of 10,000 cells:\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nFindVariableFeatures()\nAs before, this generates a list of highly variable genes.\n\n\nScaleData()\nHighly variable genes will be confounded with the most highly expressed genes, so we need to adjust for this by scaling and centering the normalized counts.\n\n\nRunPCA()\nPerform a principal component analysis using our scaled data and variable genes. This will emphasize variation in gene expression as well as similarity across bins.\n\n\nFindNeighbors()\nDetermine the Euclidean distance between bins in PCA space.\n\n\nFindClusters()\nIteratively group bins together based on neighborhood distances. Higher resolution will yield more groups.\n\n\n\n\n\n\n\n\n\nscRNA-seq workflow\n\n\n\n\n\nThese steps are all a part the standard single-cell RNA-seq workflow. For more detailed information on what each of these steps are, we have a scRNA workshop that detailed each of these steps shown in the following workflow and considerations that should be made:\n\n\n\n\n\n\n\nVariable Features\nWe will calculate the HVGs to use as inputs for Principal Component Analysis (PCA) for the next step. We can also visualize each gene’s average expression across the bins on the x-axis and variance on the y-axis.\n\nobject_filt &lt;- FindVariableFeatures(object_filt)\n\n# Identify the 15 most highly variable genes\nranked_variable_genes &lt;- VariableFeatures(object_filt,\n                                          assay = \"sketch\")\ntop_genes &lt;- ranked_variable_genes[1:15]\n\n# Plot the average expression and variance of these genes\n# With labels to indicate which genes are in the top 15\np &lt;- VariableFeaturePlot(object_filt)\nLabelPoints(plot = p, points = top_genes, repel = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nYou may notice that the top variable features are slightly different from when we calculated them previously. Why might that be the case?\n\n\n\n\nPCA\nPrincipal Component Analysis (PCA) is a technique used to emphasize both variation and similarity to reveal strong patterns within a dataset. It is one of the methods used for dimensionality reduction. PCA calculates values that represent how similar bins are to one another.\nWe would expect that bins with similar gene expression will have similar PC values. For example, we would anticipate that two Fibroblast cells would have comparable gene expression - which would result in similar scores in their principal components. This is why many of the downstream steps in the remainder of this lesson use PCA as the input.\n\nobject_filt &lt;- ScaleData(object_filt)\nobject_filt &lt;- RunPCA(object_filt, assay = \"sketch\", \n                      reduction.name = \"pca.sketch\")\n\nWe can explore the PCs using heatmaps to explore how each principal component (PC) relates to gene expression. For each PC, we show the genes with the strongest positive and negative loadings (with bins ordered by PC scores). This lets us see whether the genes that drive a given PC separate different cell types, as indicated by contrasting expression patterns between bins with high (positive) and low (negative) PC scores.\n\n# Explore heatmap of PCs \nDimHeatmap(object_filt, \n           reduction = \"pca.sketch\",\n           dims = 1:6, \n           cells = 500, \n           balanced = TRUE)\n\n\n\n\n\n\n\n\n\n\nNeighborhoods and Clusters\nIn order to properly group our bins together, we first construct a K-nearest neighbor (KNN) graph based on the PCA space; where edges are drawn between bins with similar gene expression profiles. Then, we refine edge weights between any two bins based on shared overlap within their local neighborhoods.\nFrom these neighborhoods, the FindClusters() function iteratively groups bins together using the Louvain algorithm. The size of the clusters is determined by the resolution parameter. Higher resolution values produce a larger number of smaller clusters, which big datasets often require. Typically, you would test multiple different cluster resolutions to find a resolution that represents the different cell states in the dataset.\nHere we are going to use resolution = 0.65.\n\n# K-nearest neighbors\nobject_filt &lt;- FindNeighbors(object_filt, assay = \"sketch\", \n                             reduction = \"pca.sketch\", dims = 1:50)\n\n# Louvain clustering\nobject_filt &lt;- FindClusters(object_filt, \n                            cluster.name = \"seurat_cluster.sketched\", \n                            resolution = 0.65)\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10000\nNumber of edges: 401729\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9013\nNumber of communities: 20\nElapsed time: 0 seconds\n\n\nWe can also see how many bins belong to each one of our clusters:\n\nggplot(object_filt@meta.data) +\n  geom_bar(aes(x = seurat_cluster.sketched, \n               fill = seurat_cluster.sketched)) +\n  theme_bw() + NoLegend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nWhy are there so many NA values in our results?\n\n\n\n\nUMAP\nFinally, let’s construct a UMAP embedding using the principal components as input. UMAP is a nonlinear dimensionality reduction method that preserves local neighbourhood structure, placing bins that are similar in high-dimensional expression space together in a low-dimensional representation. This is useful for visualizing our newly calculated clusters. We observe clear separation between bins assigned to different clusters, which is sign that our clustering captures biologically distinct cell types or states.\n\nobject_filt &lt;- RunUMAP(object_filt, reduction = \"pca.sketch\", \n                       reduction.name = \"umap.sketch\", return.model = T, \n                       dims = 1:50)\n\n# Plot UMAP\nDimPlot(object_filt, reduction = \"umap.sketch\", \n        label = T, cols = 'polychrome') + \n  ggtitle(\"Sketched clustering\") + NoLegend()\n\n\n\n\n\n\n\n\nWe can also examine our object after these manipulations and note the additions of the scale.data layer as well as the sketch PCA and UMAP dimensional reductions.\n\nobject_filt\n\nAn object of class Seurat \n64570 features across 41818 samples within 2 assays \nActive assay: sketch (32285 features, 2000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: Spatial.016um\n 2 dimensional reductions calculated: pca.sketch, umap.sketch\n 1 spatial field of view present: slice1.016um"
  },
  {
    "objectID": "lessons/visium_hd.html#project-clusters-back-to-entire-dataset",
    "href": "lessons/visium_hd.html#project-clusters-back-to-entire-dataset",
    "title": "Visium HD Analysis",
    "section": "Project Clusters Back to Entire Dataset",
    "text": "Project Clusters Back to Entire Dataset\nNow that we have our clusters and dimensional reductions from our sketched dataset, we next need to extend these to the full dataset. The ProjectData function projects all the bins in the dataset (the Spatial.016um assay) into the low dimensional space learned from the sketch assay.\n\nobject_filt &lt;- ProjectData(\n  object = object_filt,\n  assay = \"Spatial.016um\",\n  full.reduction = \"full.pca.sketch\",\n  sketched.assay = \"sketch\",\n  sketched.reduction = \"pca.sketch\",\n  umap.model = \"umap.sketch\",\n  dims = 1:50,\n  refdata = list(seurat_cluster.projected = \"seurat_cluster.sketched\")\n)\nobject_filt\n\nAn object of class Seurat \n64570 features across 41818 samples within 2 assays \nActive assay: sketch (32285 features, 2000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: Spatial.016um\n 4 dimensional reductions calculated: pca.sketch, umap.sketch, full.pca.sketch, full.umap.sketch\n 1 spatial field of view present: slice1.016um\n\n\nThe ProjectData function uses the sketch PCA and UMAP to return a Seurat object that includes:\n\nDimensional reduction (PCA) - The full.pca.sketch dimensional reduction extends the PCA reduction on the sketched cells to all bins in the dataset\nDimensional reduction (UMAP) - The full.umap.sketch dimensional reduction extends the UMAP reduction on the sketched cells to all bins in the dataset\nCluster labels - The seurat_cluster.projected column in the object metadata now labels all cells in the dataset with one of the cluster labels derived from the sketched cells\n\nWe can now see the additional full-dataset reductions in the object.\n\n\n\nNote that a score for the projection of each bin will be saved as a column in the metadata. If we view the metadata again, we’ll see that the seurat_cluster.sketched column contains many NA values because the clusters were only calculated for 10,000 bins.\n\nView(object_filt@meta.data)\n\n\n\n\n\n\n\n\nVisualizing the Projected Clusters on UMAP\nWe can now visualize our clusters from the projected assignments. The UMAP plot contains more points, as expected because we are now visualizing the full dataset rather than our 10,000 bin sketch. Nonetheless, we can see that the full dataset is still well-represented by the projected dimensional reduction and clustering.\n\n# switch to full dataset assay\nDefaultAssay(object_filt) &lt;- \"Spatial.016um\"\n\n# Change the idents to the projected cluster assignments\nIdents(object_filt) &lt;- \"seurat_cluster.projected\"\n\n# Plot the UMAP\nDimPlot(object_filt, reduction = \"full.umap.sketch\", label = T, \n        raster = F, cols = 'polychrome') +\n  ggtitle(\"Projected clustering\") + NoLegend()\n\n\n\n\n\n\n\n\n\n\nVisualizing Projected Clusters on the Image\nWe can use the SpatialDimPlot() function to see the clusters superimposed on our spatial slide. We will also set the color palette and convert the cluster assignments to a factor so they are ordered numerically rather than lexicographically in the figure.\n\n# Sort clusters so they get listed in numerical order\norder &lt;- object_filt$seurat_cluster.projected %&gt;%\n  unique() %&gt;% as.numeric() %&gt;%\n  sort() %&gt;% as.character()\n\nobject_filt$seurat_cluster.projected &lt;- factor(object_filt$seurat_cluster.projected,\n                                               levels = order)\n\n# Create color palette\ncolor_pal &lt;- Seurat::DiscretePalette(n = length(order),\n                                     palette = \"polychrome\")\nnames(color_pal) &lt;- order\n\n# Visualize clusters on slide\nimage_seurat_clusters &lt;- SpatialDimPlot(object_filt, \n                                        group.by = 'seurat_cluster.projected', \n                                        pt.size.factor = 8, cols = color_pal) +\n  guides(fill=guide_legend(ncol=2))\n\nimage_seurat_clusters"
  },
  {
    "objectID": "lessons/visium_hd.html#sketch-and-process-the-spatial-query-dataset",
    "href": "lessons/visium_hd.html#sketch-and-process-the-spatial-query-dataset",
    "title": "Visium HD Analysis",
    "section": "Sketch and process the spatial query dataset",
    "text": "Sketch and process the spatial query dataset\nSince we have subset the dataset, we now need to re-run the typical scRNA workflow. Without the rest of the bins, we should be able to recognize more subtle shifts in the cortex bins. Therefore, we need re-calculate the variable genes and following steps to clearly delineate the layers.\n\n# Create sketch of cortex subset\nDefaultAssay(cortex) &lt;- 'Spatial.016um'\ncortex &lt;- FindVariableFeatures(cortex)\ncortex &lt;- SketchData(\n  object = cortex,\n  ncells = 3000,\n  method = \"LeverageScore\",\n  sketched.assay = \"sketch\"\n)\n\n# Run through scRNA workflow\nDefaultAssay(cortex) &lt;- \"sketch\"\ncortex &lt;- ScaleData(cortex)\ncortex &lt;- RunPCA(cortex, assay = \"sketch\", \n                 reduction.name = \"pca.cortex.sketch\", verbose = T)\ncortex &lt;- FindNeighbors(cortex, reduction = \"pca.cortex.sketch\", dims = 1:50)\ncortex &lt;- RunUMAP(cortex, reduction = \"pca.cortex.sketch\", \n                  reduction.name = \"umap.cortex.sketch\", return.model = T, \n                  dims = 1:50, verbose = T)\n\nRCTD requires a unique data structure (similar to Seurat) as input to run. So we create our query object with SpatialRNA() by suppling the spatial coordinates and raw counts for the bins.\n\n# Grab barcodes for sketched bins\ncounts_hd &lt;- cortex[[\"sketch\"]]$counts\ncortex_cells_hd &lt;- colnames(cortex[[\"sketch\"]])\n\n# Spatial coordinates for each bin\ncoords &lt;- GetTissueCoordinates(cortex)[cortex_cells_hd, 1:2]\n\n# Create the RCTD query object\nquery &lt;- SpatialRNA(coords, counts_hd, colSums(counts_hd))"
  },
  {
    "objectID": "lessons/visium_hd.html#load-and-format-the-reference-dataset",
    "href": "lessons/visium_hd.html#load-and-format-the-reference-dataset",
    "title": "Visium HD Analysis",
    "section": "Load and format the reference dataset",
    "text": "Load and format the reference dataset\nAfter loading our reference dataset, we can take a quick look at the different celltypes that we are going to annotate our query object with. For this reference, these annotation values are stored in the column subclass_label. Note that this reference dataset was downsampled for ease of loading onto a laptop.\n\n# Increase amount of memory R can use\nmem.maxVSize(15000)\n\n[1] 15000\n\n# Load Allen Brain reference\nref_subset &lt;- qread(\"data_processed/allen_scRNAseq_ref_subset.qs\")\n\n# Plot number of cells per celltype\nggplot(ref_subset@meta.data) +\n  geom_bar(aes(x = subclass_label, \n               fill = subclass_label)) +\n  theme_bw() + NoLegend() +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\n\n\n\n\nWe are going to make another RCTD object out of the reference dataset. This time we use the Reference() function and additionally supply cluster (celltype) information to transfer to our query.\n\n# Raw counts of reference dataset\ncounts &lt;- ref_subset[[\"RNA\"]]$counts\n\n# Celltype annotation of reference dataset\nIdents(ref_subset) &lt;- \"subclass_label\"\ncluster &lt;- as.factor(ref_subset$subclass_label)\nlevels(cluster) &lt;- gsub(\"/\", \"-\", levels(cluster))\ncluster &lt;- droplevels(cluster)\n\n# Raw counts of reference dataset\nnUMI &lt;- ref_subset$nCount_RNA\n\n# Create the RCTD reference object\nreference &lt;- Reference(counts, cluster, nUMI)"
  },
  {
    "objectID": "lessons/visium_hd.html#apply-rctd-to-deconvolute-the-sketched-cortical-cells-and-annotate-them",
    "href": "lessons/visium_hd.html#apply-rctd-to-deconvolute-the-sketched-cortical-cells-and-annotate-them",
    "title": "Visium HD Analysis",
    "section": "Apply RCTD to deconvolute the “sketched” cortical cells and annotate them",
    "text": "Apply RCTD to deconvolute the “sketched” cortical cells and annotate them\nNote that run.RCTD takes 10-15 minutes to complete on a laptop using 6 cores.\n\n# Run RCTD\nRCTD &lt;- create.RCTD(query, reference, max_cores = 6)\nRCTD &lt;- run.RCTD(RCTD, doublet_mode = \"doublet\") # this command takes ~15 mins to run\n\n# Add results back to Seurat object\ncortex &lt;- AddMetaData(cortex, metadata = RCTD@results$results_df)\n\n\n\n\n\n\n\nRCTD output\n\n\n\n\n\nThe resultant dataframe from RCTD will contain the following columns according to the documentation:\n\nspot_class, a factor variable representing RCTD’s classification in doublet mode:\n\n“singlet” (1 cell type on pixel)\n“doublet_certain” (2 cell types on pixel)\n“doublet_uncertain” (2 cell types on pixel, but only confident of 1)\n“reject” (no prediction given for pixel)\n\nfirst_type column gives the first cell type predicted on the bead (for all spot_class conditions except “reject”).\nsecond_type column gives the second cell type predicted on the bead for doublet spot_class conditions (not a confident prediction for “doublet_uncertain”).\n\nWhich we can access from our cortex object:\n\n# Columns of interest\ncols &lt;- c(\"spot_class\", \"first_type\", \"second_type\")\n\n# View columns of interest (ignore NA values)\ncortex@meta.data[cols] %&gt;%\n  subset(!is.na(spot_class)) %&gt;%\n  View()"
  },
  {
    "objectID": "lessons/visium_hd.html#project-rctd-labels-onto-all-cortical-cells",
    "href": "lessons/visium_hd.html#project-rctd-labels-onto-all-cortical-cells",
    "title": "Visium HD Analysis",
    "section": "Project RCTD labels onto all cortical cells",
    "text": "Project RCTD labels onto all cortical cells\nWe once again use the ProjectData() function in order to annotate the full dataset, not just the sketch. These values will be stored in a new column named full_first_type\n\n# Set all NA values to \"Unknown\"\ncortex$first_type &lt;- as.character(cortex$first_type)\ncortex$first_type[is.na(cortex$first_type)] &lt;- \"Unknown\"\n\n# Project back first_type to new column called full_first_type\ncortex &lt;- ProjectData(\n  object = cortex,\n  assay = \"Spatial.016um\",\n  full.reduction = \"pca.cortex\",\n  sketched.assay = \"sketch\",\n  sketched.reduction = \"pca.cortex.sketch\",\n  umap.model = \"umap.cortex.sketch\",\n  dims = 1:50,\n  refdata = list(full_first_type = \"first_type\")\n)\n\nTo visualize the cortical layers, we first identify all the cells that belong to each annotation with CellsByIdentities(). Then, we select the layered neurons of interest using regular expressions. We do this so that when we visualize these cells later one, we can highly the cells of each layer clearly.\n\n# Identify bins by celltype\nIdents(cortex) &lt;- \"full_first_type\"\ncells &lt;- CellsByIdentities(cortex)\n\n# Excitatory neurons in the cortex are all labeled with an L* at the start\nexcitatory_names &lt;- sort(grep(\"^L.* CTX\", names(cells), value = TRUE))\nexcitatory_names\n\n[1] \"L2-3 IT CTX\" \"L4-5 IT CTX\" \"L5 IT CTX\"   \"L5 PT CTX\"   \"L5-6 NP CTX\"\n[6] \"L6 CT CTX\"   \"L6 IT CTX\"   \"L6b CTX\"    \n\n\nWe can see that the excitatory neurons are located in layers at varying cortical depths, as expected.\n\n# Plot each cortical layer separately\nSpatialDimPlot(cortex, cells.highlight = cells[excitatory_names], \n               cols.highlight = c(\"#FFFF00\", \"grey50\"), facet.highlight = T, \n               combine = T, ncol = 4, pt.size.factor = 8)"
  }
]